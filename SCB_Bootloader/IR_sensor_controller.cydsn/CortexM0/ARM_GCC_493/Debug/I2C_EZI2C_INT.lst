ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2C_EZI2C_INT.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.I2C_EZI2C_STRETCH_ISR,"ax",%progbits
  18              		.align	2
  19              		.global	I2C_EZI2C_STRETCH_ISR
  20              		.code	16
  21              		.thumb_func
  22              		.type	I2C_EZI2C_STRETCH_ISR, %function
  23              	I2C_EZI2C_STRETCH_ISR:
  24              	.LFB0:
  25              		.file 1 ".\\Generated_Source\\PSoC4\\I2C_EZI2C_INT.c"
   1:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * File Name: I2C_EZI2C_INT.c
   3:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * Version 3.0
   4:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** *
   5:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * Description:
   6:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** *  This file provides the source code to the Interrupt Service Routine for
   7:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** *  the SCB Component in EZI2C mode.
   8:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** *
   9:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * Note:
  10:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** *
  11:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** ********************************************************************************
  12:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * Copyright 2013-2015, Cypress Semiconductor Corporation.  All rights reserved.
  13:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  14:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  15:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** * the software package with which this file was provided.
  16:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** *******************************************************************************/
  17:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  18:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** #include "I2C_PVT.h"
  19:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** #include "I2C_EZI2C_PVT.h"
  20:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  21:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  22:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** #if(I2C_EZI2C_SCL_STRETCH_ENABLE_CONST)
  23:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     /*******************************************************************************
  24:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     * Function Name: I2C_EZI2C_STRETCH_ISR
  25:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     ********************************************************************************
  26:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *
  27:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     * Summary:
  28:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *  Handles the Interrupt Service Routine for the SCB EZI2C mode. The clock stretching is
  29:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *  used during operation.
  30:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *
  31:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     * Parameters:
  32:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *  None
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 2


  33:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *
  34:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     * Return:
  35:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *  None
  36:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *
  37:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     *******************************************************************************/
  38:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     CY_ISR_PROTO(I2C_EZI2C_STRETCH_ISR)
  39:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     {
  26              		.loc 1 39 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 7, -8
  31              		.cfi_offset 14, -4
  32 0002 88B0     		sub	sp, sp, #32
  33              		.cfi_def_cfa_offset 40
  34 0004 00AF     		add	r7, sp, #0
  35              		.cfi_def_cfa_register 7
  40:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         static uint16 locBufSize;
  41:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 locIndex;
  42:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 locStatus;
  43:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  44:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 endTransfer;
  45:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 fifoIndex;
  46:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 locByte;
  47:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  48:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 locIntrCause;
  49:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 locIntrSlave;
  50:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         
  51:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #ifdef I2C_EZI2C_STRETCH_ISR_ENTRY_CALLBACK
  52:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         I2C_EZI2C_STRETCH_ISR_EntryCallback();
  53:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #endif /* I2C_EZI2C_STRETCH_ISR_ENTRY_CALLBACK */
  54:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  55:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #if(I2C_SECONDARY_ADDRESS_ENABLE_CONST)
  56:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         /* Variable intended to be used with either buffer */
  57:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         static volatile uint8 * I2C_dataBuffer; /* Pointer to data buffer              */
  58:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         static uint16 I2C_bufSizeBuf;           /* Size of buffer in bytes             */
  59:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         static uint16 I2C_protectBuf;           /* Start index of write protected area */
  60:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  61:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         static uint8 activeAddress;
  62:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         uint32 ackResponse;
  63:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  64:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         ackResponse = I2C_EZI2C_ACK_RECEIVED_ADDRESS;
  65:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #endif /* (I2C_SECONDARY_ADDRESS_ENABLE_CONST) */
  66:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  67:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #if !defined (CY_REMOVE_I2C_CUSTOM_INTR_HANDLER)
  68:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         if(NULL != I2C_customIntrHandler)
  36              		.loc 1 68 0
  37 0006 CD4B     		ldr	r3, .L40
  38 0008 1B68     		ldr	r3, [r3]
  39 000a 002B     		cmp	r3, #0
  40 000c 02D0     		beq	.L2
  69:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         {
  70:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_customIntrHandler();
  41              		.loc 1 70 0
  42 000e CB4B     		ldr	r3, .L40
  43 0010 1B68     		ldr	r3, [r3]
  44 0012 9847     		blx	r3
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 3


  45              	.L2:
  71:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         }
  72:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #else
  73:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         CY_I2C_CUSTOM_INTR_HANDLER();
  74:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #endif /* !defined (CY_REMOVE_I2C_CUSTOM_INTR_HANDLER) */
  75:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  76:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         /* Make local copy of global variable */
  77:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         locIndex = I2C_EZI2C_GET_INDEX(activeAddress);
  46              		.loc 1 77 0
  47 0014 CA4B     		ldr	r3, .L40+4
  48 0016 1B88     		ldrh	r3, [r3]
  49 0018 FB61     		str	r3, [r7, #28]
  78:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  79:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         /* Get interrupt sources */
  80:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         locIntrSlave = I2C_GetSlaveInterruptSource();
  50              		.loc 1 80 0
  51 001a CA4B     		ldr	r3, .L40+8
  52 001c 1B68     		ldr	r3, [r3]
  53 001e FB60     		str	r3, [r7, #12]
  81:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         locIntrCause = I2C_GetInterruptCause();
  54              		.loc 1 81 0
  55 0020 C94B     		ldr	r3, .L40+12
  56 0022 1B68     		ldr	r3, [r3]
  57 0024 BB60     		str	r3, [r7, #8]
  82:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  83:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         /* INTR_SLAVE.I2C_ARB_LOST and INTR_SLAVE_I2C.BUS_ERROR */
  84:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         /* Handles errors on the bus. There are cases when both bits are set.
  85:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         * The error recovery is common: re-enable the scb IP. The content of the RX FIFO is lost.
  86:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         */
  87:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         if(0u != (locIntrSlave & (I2C_INTR_SLAVE_I2C_ARB_LOST |
  58              		.loc 1 87 0
  59 0026 FA68     		ldr	r2, [r7, #12]
  60 0028 0223     		mov	r3, #2
  61 002a FF33     		add	r3, r3, #255
  62 002c 1340     		and	r3, r2
  63 002e 57D0     		beq	.L3
  88:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                   I2C_INTR_SLAVE_I2C_BUS_ERROR)))
  89:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         {
  90:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_CTRL_REG &= (uint32) ~I2C_CTRL_ENABLED; /* Disable SCB block */
  64              		.loc 1 90 0
  65 0030 C64B     		ldr	r3, .L40+16
  66 0032 C64A     		ldr	r2, .L40+16
  67 0034 1268     		ldr	r2, [r2]
  68 0036 5200     		lsl	r2, r2, #1
  69 0038 5208     		lsr	r2, r2, #1
  70 003a 1A60     		str	r2, [r3]
  91:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  92:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         #if(I2C_CY_SCBIP_V0)
  93:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             if(0u != ((uint8) I2C_EZI2C_STATUS_BUSY & I2C_curStatus))
  71              		.loc 1 93 0
  72 003c C44B     		ldr	r3, .L40+20
  73 003e 1B78     		ldrb	r3, [r3]
  74 0040 DBB2     		uxtb	r3, r3
  75 0042 2022     		mov	r2, #32
  76 0044 1340     		and	r3, r2
  77 0046 DBB2     		uxtb	r3, r3
  78 0048 002B     		cmp	r3, #0
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 4


  79 004a 2CD0     		beq	.L4
  94:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         #endif /* (I2C_CY_SCBIP_V0) */
  95:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             {
  96:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 I2C_curStatus &= (uint8) ~I2C_EZI2C_STATUS_BUSY;
  80              		.loc 1 96 0
  81 004c C04B     		ldr	r3, .L40+20
  82 004e 1B78     		ldrb	r3, [r3]
  83 0050 DBB2     		uxtb	r3, r3
  84 0052 2022     		mov	r2, #32
  85 0054 9343     		bic	r3, r2
  86 0056 DAB2     		uxtb	r2, r3
  87 0058 BD4B     		ldr	r3, .L40+20
  88 005a 1A70     		strb	r2, [r3]
  97:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 I2C_curStatus |= (uint8)  I2C_EZI2C_STATUS_ERR;
  89              		.loc 1 97 0
  90 005c BC4B     		ldr	r3, .L40+20
  91 005e 1B78     		ldrb	r3, [r3]
  92 0060 DBB2     		uxtb	r3, r3
  93 0062 1022     		mov	r2, #16
  94 0064 1343     		orr	r3, r2
  95 0066 DAB2     		uxtb	r2, r3
  96 0068 B94B     		ldr	r3, .L40+20
  97 006a 1A70     		strb	r2, [r3]
  98:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
  99:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* INTR_TX_EMPTY is enabled in the address phase to receive data */
 100:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 if(0u == (I2C_GetTxInterruptMode() & I2C_INTR_TX_EMPTY))
  98              		.loc 1 100 0
  99 006c B94B     		ldr	r3, .L40+24
 100 006e 1B68     		ldr	r3, [r3]
 101 0070 1022     		mov	r2, #16
 102 0072 1340     		and	r3, r2
 103 0074 0FD1     		bne	.L5
 101:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 102:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Write complete */
 103:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     if(I2C_indexBuf1 != I2C_offsetBuf1)
 104              		.loc 1 103 0
 105 0076 B84B     		ldr	r3, .L40+28
 106 0078 1B78     		ldrb	r3, [r3]
 107 007a 9AB2     		uxth	r2, r3
 108 007c B04B     		ldr	r3, .L40+4
 109 007e 1B88     		ldrh	r3, [r3]
 110 0080 9A42     		cmp	r2, r3
 111 0082 10D0     		beq	.L4
 104:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 105:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_curStatus |= (uint8) I2C_INTR_SLAVE_I2C_WRITE_STOP;
 112              		.loc 1 105 0
 113 0084 B24B     		ldr	r3, .L40+20
 114 0086 1B78     		ldrb	r3, [r3]
 115 0088 DBB2     		uxtb	r3, r3
 116 008a 0822     		mov	r2, #8
 117 008c 1343     		orr	r3, r2
 118 008e DAB2     		uxtb	r2, r3
 119 0090 AF4B     		ldr	r3, .L40+20
 120 0092 1A70     		strb	r2, [r3]
 121 0094 07E0     		b	.L4
 122              	.L5:
 106:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 5


 107:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
 108:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 else
 109:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 110:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Read complete */
 111:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     I2C_curStatus |= (uint8) I2C_INTR_SLAVE_I2C_NACK;
 123              		.loc 1 111 0
 124 0096 AE4B     		ldr	r3, .L40+20
 125 0098 1B78     		ldrb	r3, [r3]
 126 009a DBB2     		uxtb	r3, r3
 127 009c 0222     		mov	r2, #2
 128 009e 1343     		orr	r3, r2
 129 00a0 DAB2     		uxtb	r2, r3
 130 00a2 AB4B     		ldr	r3, .L40+20
 131 00a4 1A70     		strb	r2, [r3]
 132              	.L4:
 112:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
 113:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             }
 114:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 115:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_DISABLE_SLAVE_AUTO_DATA;
 133              		.loc 1 115 0
 134 00a6 AD4B     		ldr	r3, .L40+32
 135 00a8 AC4A     		ldr	r2, .L40+32
 136 00aa 1268     		ldr	r2, [r2]
 137 00ac AC49     		ldr	r1, .L40+36
 138 00ae 0A40     		and	r2, r1
 139 00b0 1A60     		str	r2, [r3]
 116:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 117:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             /* Disable TX and RX interrupt sources */
 118:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 140              		.loc 1 118 0
 141 00b2 AC4B     		ldr	r3, .L40+40
 142 00b4 0022     		mov	r2, #0
 143 00b6 1A60     		str	r2, [r3]
 119:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 144              		.loc 1 119 0
 145 00b8 A64B     		ldr	r3, .L40+24
 146 00ba 0022     		mov	r2, #0
 147 00bc 1A60     		str	r2, [r3]
 120:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 121:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         #if(I2C_CY_SCBIP_V0)
 122:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             /* Clear interrupt sources as they are not automatically cleared after SCB is disabled 
 123:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 148              		.loc 1 123 0
 149 00be AA4B     		ldr	r3, .L40+44
 150 00c0 AA4A     		ldr	r2, .L40+48
 151 00c2 1A60     		str	r2, [r3]
 124:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 152              		.loc 1 124 0
 153 00c4 9F4B     		ldr	r3, .L40+8
 154 00c6 AA4A     		ldr	r2, .L40+52
 155 00c8 1A60     		str	r2, [r3]
 125:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         #endif /* (I2C_CY_SCBIP_V0) */
 126:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 127:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_fsmState = I2C_EZI2C_FSM_IDLE;
 156              		.loc 1 127 0
 157 00ca AA4B     		ldr	r3, .L40+56
 158 00cc 0022     		mov	r2, #0
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 6


 159 00ce 1A70     		strb	r2, [r3]
 128:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 129:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             I2C_CTRL_REG |= (uint32) I2C_CTRL_ENABLED;  /* Enable SCB block */
 160              		.loc 1 129 0
 161 00d0 9E4B     		ldr	r3, .L40+16
 162 00d2 9E4A     		ldr	r2, .L40+16
 163 00d4 1268     		ldr	r2, [r2]
 164 00d6 8021     		mov	r1, #128
 165 00d8 0906     		lsl	r1, r1, #24
 166 00da 0A43     		orr	r2, r1
 167 00dc 1A60     		str	r2, [r3]
 168 00de 99E1     		b	.L7
 169              	.L3:
 130:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         }
 131:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         else
 132:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         {
 133:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             /* INTR_I2C_EC_WAKE_UP */
 134:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             /* Wakes up device from deep sleep */
 135:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             if(0u != (locIntrCause & I2C_INTR_CAUSE_I2C_EC))
 170              		.loc 1 135 0
 171 00e0 BB68     		ldr	r3, [r7, #8]
 172 00e2 1022     		mov	r2, #16
 173 00e4 1340     		and	r3, r2
 174 00e6 02D0     		beq	.L8
 136:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             {
 137:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* Disables wakeup interrupt source but does not clear it. It is cleared in INTR_SL
 138:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 I2C_SetI2CExtClkInterruptMode(I2C_NO_INTR_SOURCES);
 175              		.loc 1 138 0
 176 00e8 A34B     		ldr	r3, .L40+60
 177 00ea 0022     		mov	r2, #0
 178 00ec 1A60     		str	r2, [r3]
 179              	.L8:
 139:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             }
 140:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 141:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             if(0u != (locIntrCause & (I2C_INTR_CAUSE_RX | I2C_INTR_CAUSE_SLAVE)))
 180              		.loc 1 141 0
 181 00ee BB68     		ldr	r3, [r7, #8]
 182 00f0 0A22     		mov	r2, #10
 183 00f2 1340     		and	r3, r2
 184 00f4 00D1     		bne	.LCB147
 185 00f6 C3E0     		b	.L9	@long jump
 186              	.LCB147:
 142:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             {
 143:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* INTR_RX.NOT_EMPTY */
 144:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* Receives data byte-by-byte. Does not use RX FIFO capabilities */
 145:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 if (0u != (I2C_GetRxInterruptSourceMasked() & I2C_INTR_RX_NOT_EMPTY))
 187              		.loc 1 145 0
 188 00f8 A04B     		ldr	r3, .L40+64
 189 00fa 1B68     		ldr	r3, [r3]
 190 00fc 0422     		mov	r2, #4
 191 00fe 1340     		and	r3, r2
 192 0100 00D1     		bne	.LCB153
 193 0102 6FE0     		b	.L10	@long jump
 194              	.LCB153:
 146:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 147:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 #if(I2C_SECONDARY_ADDRESS_ENABLE_CONST)
 148:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* If I2C_STOP service is delayed to I2C_ADDR_MATCH the address byte is in the 
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 7


 149:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     * RX_NOT_EMPTY is enabled. The address byte has to stay into RX FIFO therefore
 150:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     * RX.NOT_EMPTY service has to be skipped. The address byte has to be read by I2
 151:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     */
 152:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     if (0u == (locIntrCause & I2C_INTR_CAUSE_SLAVE))
 153:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 #endif /* (I2C_SECONDARY_ADDRESS_ENABLE_CONST) */
 154:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 155:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locByte = I2C_RX_FIFO_RD_REG;
 195              		.loc 1 155 0
 196 0104 9E4B     		ldr	r3, .L40+68
 197 0106 1B68     		ldr	r3, [r3]
 198 0108 7B60     		str	r3, [r7, #4]
 156:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 157:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         switch(I2C_fsmState)
 199              		.loc 1 157 0
 200 010a 9A4B     		ldr	r3, .L40+56
 201 010c 1B78     		ldrb	r3, [r3]
 202 010e 002B     		cmp	r3, #0
 203 0110 1CD0     		beq	.L12
 204 0112 012B     		cmp	r3, #1
 205 0114 5ED1     		bne	.L39
 158:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 159:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         case I2C_EZI2C_FSM_BYTE_WRITE:
 160:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             if(0u != locBufSize)
 206              		.loc 1 160 0
 207 0116 9B4B     		ldr	r3, .L40+72
 208 0118 1B88     		ldrh	r3, [r3]
 209 011a 002B     		cmp	r3, #0
 210 011c 13D0     		beq	.L14
 161:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             {
 162:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Store data byte and ACK */
 163:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 I2C_I2C_SLAVE_GENERATE_ACK;
 211              		.loc 1 163 0
 212 011e 9A4B     		ldr	r3, .L40+76
 213 0120 0122     		mov	r2, #1
 214 0122 1A60     		str	r2, [r3]
 164:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 165:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 I2C_dataBuffer1[locIndex] = (uint8) locByte;
 215              		.loc 1 165 0
 216 0124 994B     		ldr	r3, .L40+80
 217 0126 1A68     		ldr	r2, [r3]
 218 0128 FB69     		ldr	r3, [r7, #28]
 219 012a D318     		add	r3, r2, r3
 220 012c 7A68     		ldr	r2, [r7, #4]
 221 012e D2B2     		uxtb	r2, r2
 222 0130 1A70     		strb	r2, [r3]
 166:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 locIndex++;
 223              		.loc 1 166 0
 224 0132 FB69     		ldr	r3, [r7, #28]
 225 0134 0133     		add	r3, r3, #1
 226 0136 FB61     		str	r3, [r7, #28]
 167:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 locBufSize--;
 227              		.loc 1 167 0
 228 0138 924B     		ldr	r3, .L40+72
 229 013a 1B88     		ldrh	r3, [r3]
 230 013c 013B     		sub	r3, r3, #1
 231 013e 9AB2     		uxth	r2, r3
 232 0140 904B     		ldr	r3, .L40+72
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 8


 233 0142 1A80     		strh	r2, [r3]
 168:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 169:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             else
 170:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             {
 171:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Discard data byte and NACK */
 172:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 I2C_I2C_SLAVE_GENERATE_NACK;
 173:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 174:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             break;
 234              		.loc 1 174 0
 235 0144 4AE0     		b	.L16
 236              	.L14:
 172:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 237              		.loc 1 172 0
 238 0146 FFF7FEFF 		bl	I2C_I2CSlaveNackGeneration
 239              		.loc 1 174 0
 240 014a 47E0     		b	.L16
 241              	.L12:
 175:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 176:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #if(I2C_SUB_ADDRESS_SIZE16_CONST)
 177:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         case I2C_EZI2C_FSM_OFFSET_HI8:
 178:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 179:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_I2C_SLAVE_GENERATE_ACK;
 180:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 181:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Store offset most significant byre */
 182:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             locBufSize = (uint16) ((uint8) locByte);
 183:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 184:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_fsmState = I2C_EZI2C_FSM_OFFSET_LO8;
 185:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 186:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             break;
 187:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #endif /* (I2C_SUB_ADDRESS_SIZE16_CONST) */
 188:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 189:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         case I2C_EZI2C_FSM_OFFSET_LO8:
 190:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 191:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             #if (I2C_SUB_ADDRESS_SIZE16)
 192:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             {
 193:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Collect 2 bytes offset */
 194:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 locByte = ((uint32) ((uint32) locBufSize << 8u)) | locByte;
 195:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 196:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             #endif
 197:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 198:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Check offset against buffer size */
 199:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             if(locByte < (uint32) I2C_bufSizeBuf1)
 242              		.loc 1 199 0
 243 014c 904B     		ldr	r3, .L40+84
 244 014e 1B88     		ldrh	r3, [r3]
 245 0150 1A1E     		sub	r2, r3, #0
 246 0152 7B68     		ldr	r3, [r7, #4]
 247 0154 9A42     		cmp	r2, r3
 248 0156 3AD9     		bls	.L17
 200:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             {
 201:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 I2C_I2C_SLAVE_GENERATE_ACK;
 249              		.loc 1 201 0
 250 0158 8B4B     		ldr	r3, .L40+76
 251 015a 0122     		mov	r2, #1
 252 015c 1A60     		str	r2, [r3]
 202:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 203:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Update local buffer index with new offset */
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 9


 204:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 locIndex = locByte;
 253              		.loc 1 204 0
 254 015e 7B68     		ldr	r3, [r7, #4]
 255 0160 FB61     		str	r3, [r7, #28]
 205:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 206:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Get available buffer size to write */
 207:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 locBufSize = (uint16) ((locByte < I2C_protectBuf1) ?
 256              		.loc 1 207 0
 257 0162 8C4B     		ldr	r3, .L40+88
 258 0164 1B88     		ldrh	r3, [r3]
 259 0166 1A1E     		sub	r2, r3, #0
 260 0168 7B68     		ldr	r3, [r7, #4]
 261 016a 9A42     		cmp	r2, r3
 262 016c 06D9     		bls	.L18
 263              		.loc 1 207 0 is_stmt 0 discriminator 1
 264 016e 894B     		ldr	r3, .L40+88
 265 0170 1A88     		ldrh	r2, [r3]
 266 0172 7B68     		ldr	r3, [r7, #4]
 267 0174 9BB2     		uxth	r3, r3
 268 0176 D31A     		sub	r3, r2, r3
 269 0178 9AB2     		uxth	r2, r3
 270 017a 00E0     		b	.L19
 271              	.L18:
 272              		.loc 1 207 0 discriminator 2
 273 017c 0022     		mov	r2, #0
 274              	.L19:
 275              		.loc 1 207 0 discriminator 4
 276 017e 814B     		ldr	r3, .L40+72
 277 0180 1A80     		strh	r2, [r3]
 208:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                                        (I2C_protectBuf1 - locByte) : (0u));
 209:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 210:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             #if(I2C_CY_SCBIP_V0)
 211:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 212:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 if(locBufSize < I2C_EZI2C_FIFO_SIZE)
 278              		.loc 1 212 0 is_stmt 1 discriminator 4
 279 0182 804B     		ldr	r3, .L40+72
 280 0184 1B88     		ldrh	r3, [r3]
 281 0186 072B     		cmp	r3, #7
 282 0188 03D8     		bhi	.L20
 213:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 {
 214:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     /* Set FSM state to receive byte by byte */
 215:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     I2C_fsmState = I2C_EZI2C_FSM_BYTE_WRITE;
 283              		.loc 1 215 0
 284 018a 7A4B     		ldr	r3, .L40+56
 285 018c 0122     		mov	r2, #1
 286 018e 1A70     		strb	r2, [r3]
 287 0190 18E0     		b	.L21
 288              	.L20:
 216:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 }
 217:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Receive RX FIFO chunks */
 218:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 else if(locBufSize == I2C_EZI2C_FIFO_SIZE)
 289              		.loc 1 218 0
 290 0192 7C4B     		ldr	r3, .L40+72
 291 0194 1B88     		ldrh	r3, [r3]
 292 0196 082B     		cmp	r3, #8
 293 0198 0AD1     		bne	.L22
 219:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 {
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 10


 220:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA; /* NACK when RX FIFO is full */
 294              		.loc 1 220 0
 295 019a 704B     		ldr	r3, .L40+32
 296 019c 6F4A     		ldr	r2, .L40+32
 297 019e 1268     		ldr	r2, [r2]
 298 01a0 A021     		mov	r1, #160
 299 01a2 0902     		lsl	r1, r1, #8
 300 01a4 0A43     		orr	r2, r1
 301 01a6 1A60     		str	r2, [r3]
 221:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 302              		.loc 1 221 0
 303 01a8 6E4B     		ldr	r3, .L40+40
 304 01aa 0022     		mov	r2, #0
 305 01ac 1A60     		str	r2, [r3]
 306 01ae 09E0     		b	.L21
 307              	.L22:
 222:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 }
 223:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 else
 224:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 {
 225:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA_ACK; /* Stretch when RX FIFO is full
 308              		.loc 1 225 0
 309 01b0 6A4B     		ldr	r3, .L40+32
 310 01b2 6A4A     		ldr	r2, .L40+32
 311 01b4 1268     		ldr	r2, [r2]
 312 01b6 8021     		mov	r1, #128
 313 01b8 8901     		lsl	r1, r1, #6
 314 01ba 0A43     		orr	r2, r1
 315 01bc 1A60     		str	r2, [r3]
 226:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 316              		.loc 1 226 0
 317 01be 694B     		ldr	r3, .L40+40
 318 01c0 0822     		mov	r2, #8
 319 01c2 1A60     		str	r2, [r3]
 320              	.L21:
 227:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 }
 228:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 229:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             #else
 230:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 231:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 #if(I2C_SECONDARY_ADDRESS_ENABLE)
 232:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 {
 233:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     /* Set FSM state to receive byte by byte.
 234:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     * The byte by byte receive is always chosen for two addresses. 
 235:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     */
 236:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     I2C_fsmState = I2C_EZI2C_FSM_BYTE_WRITE;
 237:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 }
 238:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 #else
 239:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 {
 240:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     if (locBufSize < I2C_EZI2C_FIFO_SIZE)
 241:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     {
 242:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                         /* Set FSM state to receive byte by byte */
 243:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                         I2C_fsmState = I2C_EZI2C_FSM_BYTE_WRITE;
 244:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     }
 245:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     /* Receive RX FIFO chunks */
 246:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     else if (locBufSize == I2C_EZI2C_FIFO_SIZE)
 247:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     {
 248:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                         I2C_ENABLE_SLAVE_AUTO_DATA; /* NACK when RX FIFO is full */
 249:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                         I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 11


 250:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     }
 251:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     else
 252:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     {
 253:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                         I2C_ENABLE_SLAVE_AUTO_DATA_ACK; /* Stretch when RX FIFO is 
 254:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                         I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 255:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                     }
 256:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 }
 257:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 #endif
 258:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 259:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             #endif /* (I2C_CY_SCBIP_V0) */
 260:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 261:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Store local offset into global variable */
 262:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 I2C_EZI2C_SET_OFFSET(activeAddress, locIndex);
 321              		.loc 1 262 0
 322 01c4 FB69     		ldr	r3, [r7, #28]
 323 01c6 DAB2     		uxtb	r2, r3
 324 01c8 634B     		ldr	r3, .L40+28
 325 01ca 1A70     		strb	r2, [r3]
 263:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 264:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             else
 265:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             {
 266:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Discard offset byte and NACK */
 267:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 I2C_I2C_SLAVE_GENERATE_NACK;
 268:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 269:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             break;
 326              		.loc 1 269 0
 327 01cc 06E0     		b	.L16
 328              	.L17:
 267:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 329              		.loc 1 267 0
 330 01ce FFF7FEFF 		bl	I2C_I2CSlaveNackGeneration
 331              		.loc 1 269 0
 332 01d2 03E0     		b	.L16
 333              	.L39:
 270:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 271:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         default:
 272:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             CYASSERT(0u != 0u); /* Should never get there */
 334              		.loc 1 272 0
 335 01d4 0020     		mov	r0, #0
 336 01d6 FFF7FEFF 		bl	CyHalt
 273:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             break;
 337              		.loc 1 273 0
 338 01da C046     		mov	r8, r8
 339              	.L16:
 274:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 275:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 276:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ClearRxInterruptSource(I2C_INTR_RX_NOT_EMPTY);
 340              		.loc 1 276 0
 341 01dc 624B     		ldr	r3, .L40+44
 342 01de 0422     		mov	r2, #4
 343 01e0 1A60     		str	r2, [r3]
 344 01e2 4DE0     		b	.L9
 345              	.L10:
 277:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 278:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
 279:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* INTR_RX.FULL, INTR_SLAVE.I2C_STOP */
 280:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* Receive FIFO chunks: auto data ACK is enabled */
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 12


 281:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 else if (0u != (I2C_I2C_CTRL_REG & I2C_I2C_CTRL_S_READY_DATA_ACK))
 346              		.loc 1 281 0
 347 01e4 5D4B     		ldr	r3, .L40+32
 348 01e6 1A68     		ldr	r2, [r3]
 349 01e8 8023     		mov	r3, #128
 350 01ea 9B01     		lsl	r3, r3, #6
 351 01ec 1340     		and	r3, r2
 352 01ee 47D0     		beq	.L9
 282:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 283:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Slave interrupt (I2C_STOP or I2C_ADDR_MATCH) leads to completion of read.
 284:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     * A completion event has a higher priority than the FIFO full.
 285:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     * Read remaining data from RX FIFO.
 286:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     */
 287:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     if(0u != (locIntrCause & I2C_INTR_CAUSE_SLAVE))
 353              		.loc 1 287 0
 354 01f0 BB68     		ldr	r3, [r7, #8]
 355 01f2 0222     		mov	r2, #2
 356 01f4 1340     		and	r3, r2
 357 01f6 0DD0     		beq	.L24
 288:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 289:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Read remaining bytes from RX FIFO */
 290:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         fifoIndex = I2C_GET_RX_FIFO_ENTRIES;
 358              		.loc 1 290 0
 359 01f8 674B     		ldr	r3, .L40+92
 360 01fa 1B68     		ldr	r3, [r3]
 361 01fc 0F22     		mov	r2, #15
 362 01fe 1340     		and	r3, r2
 363 0200 3B61     		str	r3, [r7, #16]
 291:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 292:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         #if(I2C_SECONDARY_ADDRESS_ENABLE)
 293:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 294:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Update with current address match */
 295:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH))
 296:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             {
 297:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* Update RX FIFO entries as address byte is there now */
 298:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 fifoIndex = I2C_GET_RX_FIFO_ENTRIES;
 299:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 300:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 /* If SR is valid, RX FIFO is full and address is in SHIFTER:
 301:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 * read 8 entries and leave address in RX FIFO for further processin
 302:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 * If SR is invalid, address is already in RX FIFO: read (entries-1)
 303:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 */
 304:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                 fifoIndex -= ((0u != I2C_GET_RX_FIFO_SR_VALID) ? (0u) : (1u));
 305:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             }
 306:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 307:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         #endif
 308:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 309:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_DISABLE_SLAVE_AUTO_DATA;
 364              		.loc 1 309 0
 365 0202 564B     		ldr	r3, .L40+32
 366 0204 554A     		ldr	r2, .L40+32
 367 0206 1268     		ldr	r2, [r2]
 368 0208 5549     		ldr	r1, .L40+36
 369 020a 0A40     		and	r2, r1
 370 020c 1A60     		str	r2, [r3]
 310:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         endTransfer = I2C_EZI2C_CONTINUE_TRANSFER;
 371              		.loc 1 310 0
 372 020e 0123     		mov	r3, #1
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 13


 373 0210 7B61     		str	r3, [r7, #20]
 374 0212 13E0     		b	.L25
 375              	.L24:
 311:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 312:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     else
 313:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* INTR_RX_FULL */
 314:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Continue transfer or disable INTR_RX_FULL to catch completion event. */
 315:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 316:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Calculate buffer size available to write data into */
 317:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locBufSize -= (uint16) I2C_EZI2C_FIFO_SIZE;
 376              		.loc 1 317 0
 377 0214 5B4B     		ldr	r3, .L40+72
 378 0216 1B88     		ldrh	r3, [r3]
 379 0218 083B     		sub	r3, r3, #8
 380 021a 9AB2     		uxth	r2, r3
 381 021c 594B     		ldr	r3, .L40+72
 382 021e 1A80     		strh	r2, [r3]
 318:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 319:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         if(locBufSize <= I2C_EZI2C_FIFO_SIZE)
 383              		.loc 1 319 0
 384 0220 584B     		ldr	r3, .L40+72
 385 0222 1B88     		ldrh	r3, [r3]
 386 0224 082B     		cmp	r3, #8
 387 0226 05D8     		bhi	.L26
 320:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 321:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Send NACK when RX FIFO overflow */
 322:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             fifoIndex   = locBufSize;
 388              		.loc 1 322 0
 389 0228 564B     		ldr	r3, .L40+72
 390 022a 1B88     		ldrh	r3, [r3]
 391 022c 3B61     		str	r3, [r7, #16]
 323:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             endTransfer = I2C_EZI2C_COMPLETE_TRANSFER;
 392              		.loc 1 323 0
 393 022e 0023     		mov	r3, #0
 394 0230 7B61     		str	r3, [r7, #20]
 395 0232 03E0     		b	.L25
 396              	.L26:
 324:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 325:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         else
 326:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 327:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Continue  transaction */
 328:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             fifoIndex   = I2C_EZI2C_FIFO_SIZE;
 397              		.loc 1 328 0
 398 0234 0823     		mov	r3, #8
 399 0236 3B61     		str	r3, [r7, #16]
 329:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             endTransfer = I2C_EZI2C_CONTINUE_TRANSFER;
 400              		.loc 1 329 0
 401 0238 0123     		mov	r3, #1
 402 023a 7B61     		str	r3, [r7, #20]
 403              	.L25:
 330:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 331:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 332:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 333:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     for(; (0u != fifoIndex); fifoIndex--)
 404              		.loc 1 333 0
 405 023c 0DE0     		b	.L27
 406              	.L28:
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 14


 334:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 335:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Store data in buffer */
 336:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_dataBuffer1[locIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 407              		.loc 1 336 0 discriminator 2
 408 023e 534B     		ldr	r3, .L40+80
 409 0240 1A68     		ldr	r2, [r3]
 410 0242 FB69     		ldr	r3, [r7, #28]
 411 0244 D218     		add	r2, r2, r3
 412 0246 4E4B     		ldr	r3, .L40+68
 413 0248 1B68     		ldr	r3, [r3]
 414 024a DBB2     		uxtb	r3, r3
 415 024c 1370     		strb	r3, [r2]
 337:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locIndex++;
 416              		.loc 1 337 0 discriminator 2
 417 024e FB69     		ldr	r3, [r7, #28]
 418 0250 0133     		add	r3, r3, #1
 419 0252 FB61     		str	r3, [r7, #28]
 333:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 420              		.loc 1 333 0 discriminator 2
 421 0254 3B69     		ldr	r3, [r7, #16]
 422 0256 013B     		sub	r3, r3, #1
 423 0258 3B61     		str	r3, [r7, #16]
 424              	.L27:
 333:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 425              		.loc 1 333 0 is_stmt 0 discriminator 1
 426 025a 3B69     		ldr	r3, [r7, #16]
 427 025c 002B     		cmp	r3, #0
 428 025e EED1     		bne	.L28
 338:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 339:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 340:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Complete transfer sending NACK when RX FIFO overflow */
 341:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     if(I2C_EZI2C_COMPLETE_TRANSFER == endTransfer)
 429              		.loc 1 341 0 is_stmt 1
 430 0260 7B69     		ldr	r3, [r7, #20]
 431 0262 002B     		cmp	r3, #0
 432 0264 09D1     		bne	.L29
 342:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 343:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ENABLE_SLAVE_AUTO_DATA_NACK;
 433              		.loc 1 343 0
 434 0266 3D4B     		ldr	r3, .L40+32
 435 0268 3C4A     		ldr	r2, .L40+32
 436 026a 1268     		ldr	r2, [r2]
 437 026c 8021     		mov	r1, #128
 438 026e 0902     		lsl	r1, r1, #8
 439 0270 0A43     		orr	r2, r1
 440 0272 1A60     		str	r2, [r3]
 344:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 345:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Disable INTR_RX_FULL during last RX FIFO chunk reception */
 346:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 441              		.loc 1 346 0
 442 0274 3B4B     		ldr	r3, .L40+40
 443 0276 0022     		mov	r2, #0
 444 0278 1A60     		str	r2, [r3]
 445              	.L29:
 347:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 348:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 349:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     I2C_ClearRxInterruptSource(I2C_INTR_RX_FULL |
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 15


 446              		.loc 1 349 0
 447 027a 3B4B     		ldr	r3, .L40+44
 448 027c 0C22     		mov	r2, #12
 449 027e 1A60     		str	r2, [r3]
 450              	.L9:
 350:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                                                             I2C_INTR_RX_NOT_EMPTY);
 351:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
 352:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 else
 353:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 354:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Exit for slave interrupts which are not active for RX direction:
 355:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     * INTR_SLAVE.I2C_ADDR_MATCH and INTR_SLAVE.I2C_STOP while byte-by-byte receptio
 356:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     */
 357:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
 358:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             }
 359:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 360:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             if(0u != (locIntrCause & I2C_INTR_CAUSE_SLAVE))
 451              		.loc 1 360 0
 452 0280 BB68     		ldr	r3, [r7, #8]
 453 0282 0222     		mov	r2, #2
 454 0284 1340     		and	r3, r2
 455 0286 00D1     		bne	.LCB394
 456 0288 9DE0     		b	.L30	@long jump
 457              	.LCB394:
 361:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             {
 362:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* INTR_SLAVE.I2C_STOP */
 363:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* Catch Stop condition: completion of write or read transfer */
 364:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             #if(!I2C_SECONDARY_ADDRESS_ENABLE_CONST)
 365:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 if(0u != (locIntrSlave & I2C_INTR_SLAVE_I2C_STOP))
 458              		.loc 1 365 0
 459 028a FB68     		ldr	r3, [r7, #12]
 460 028c 1022     		mov	r2, #16
 461 028e 1340     		and	r3, r2
 462 0290 27D0     		beq	.L31
 366:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             #else
 367:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* Prevent triggering when matched address was NACKed */
 368:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 if((0u != (locIntrSlave & I2C_INTR_SLAVE_I2C_STOP)) &&
 369:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                    (0u != ((uint8) I2C_EZI2C_STATUS_BUSY & I2C_curStatus)))
 370:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             #endif
 371:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 372:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Disable TX and RX interrupt sources */
 373:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 463              		.loc 1 373 0
 464 0292 344B     		ldr	r3, .L40+40
 465 0294 0022     		mov	r2, #0
 466 0296 1A60     		str	r2, [r3]
 374:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 467              		.loc 1 374 0
 468 0298 2E4B     		ldr	r3, .L40+24
 469 029a 0022     		mov	r2, #0
 470 029c 1A60     		str	r2, [r3]
 375:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 376:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Set read completion mask */
 377:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     locStatus = I2C_INTR_SLAVE_I2C_NACK;
 471              		.loc 1 377 0
 472 029e 0223     		mov	r3, #2
 473 02a0 BB61     		str	r3, [r7, #24]
 378:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 16


 379:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Check if buffer content was modified: the address phase resets the locIndex 
 380:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     if(locIndex != I2C_EZI2C_GET_OFFSET(activeAddress))
 474              		.loc 1 380 0
 475 02a2 2D4B     		ldr	r3, .L40+28
 476 02a4 1B78     		ldrb	r3, [r3]
 477 02a6 1A1E     		sub	r2, r3, #0
 478 02a8 FB69     		ldr	r3, [r7, #28]
 479 02aa 9A42     		cmp	r2, r3
 480 02ac 03D0     		beq	.L32
 381:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 382:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locStatus |= I2C_INTR_SLAVE_I2C_WRITE_STOP;
 481              		.loc 1 382 0
 482 02ae BB69     		ldr	r3, [r7, #24]
 483 02b0 0822     		mov	r2, #8
 484 02b2 1343     		orr	r3, r2
 485 02b4 BB61     		str	r3, [r7, #24]
 486              	.L32:
 383:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 384:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 385:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Complete read or write transaction */
 386:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     locStatus &= locIntrSlave;
 487              		.loc 1 386 0
 488 02b6 BB69     		ldr	r3, [r7, #24]
 489 02b8 FA68     		ldr	r2, [r7, #12]
 490 02ba 1340     		and	r3, r2
 491 02bc BB61     		str	r3, [r7, #24]
 387:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     I2C_EZI2C_UPDATE_LOC_STATUS(activeAddress, locStatus);
 388:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     locStatus |= (uint32)  I2C_curStatus;
 492              		.loc 1 388 0
 493 02be 244B     		ldr	r3, .L40+20
 494 02c0 1B78     		ldrb	r3, [r3]
 495 02c2 DBB2     		uxtb	r3, r3
 496 02c4 1A1C     		mov	r2, r3
 497 02c6 BB69     		ldr	r3, [r7, #24]
 498 02c8 1343     		orr	r3, r2
 499 02ca BB61     		str	r3, [r7, #24]
 389:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     locStatus &= (uint32) ~I2C_EZI2C_STATUS_BUSY;
 500              		.loc 1 389 0
 501 02cc BB69     		ldr	r3, [r7, #24]
 502 02ce 2022     		mov	r2, #32
 503 02d0 9343     		bic	r3, r2
 504 02d2 BB61     		str	r3, [r7, #24]
 390:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     I2C_curStatus = (uint8) locStatus;
 505              		.loc 1 390 0
 506 02d4 BB69     		ldr	r3, [r7, #24]
 507 02d6 DAB2     		uxtb	r2, r3
 508 02d8 1D4B     		ldr	r3, .L40+20
 509 02da 1A70     		strb	r2, [r3]
 391:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 392:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     I2C_fsmState = I2C_EZI2C_FSM_IDLE;
 510              		.loc 1 392 0
 511 02dc 254B     		ldr	r3, .L40+56
 512 02de 0022     		mov	r2, #0
 513 02e0 1A70     		strb	r2, [r3]
 514              	.L31:
 393:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 394:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #if(I2C_SECONDARY_ADDRESS_ENABLE)
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 17


 395:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 396:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Store local index into global variable, before address phase */
 397:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_EZI2C_SET_INDEX(activeAddress, locIndex);
 398:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 399:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #endif
 400:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
 401:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 402:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* INTR_SLAVE.I2C_ADDR_MATCH */
 403:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* The matched address is received: the slave starts its operation.
 404:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 * INTR_SLAVE_I2C_STOP updates the buffer index before the address phase for two add
 405:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 * This is done to update buffer index correctly before the address phase changes it
 406:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 */
 407:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 if(0u != (locIntrSlave & I2C_INTR_SLAVE_I2C_ADDR_MATCH))
 515              		.loc 1 407 0
 516 02e2 FB68     		ldr	r3, [r7, #12]
 517 02e4 4022     		mov	r2, #64
 518 02e6 1340     		and	r3, r2
 519 02e8 6AD0     		beq	.L33
 408:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 409:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #if(I2C_SECONDARY_ADDRESS_ENABLE)
 410:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 411:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Read address byte from RX FIFO */
 412:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locByte = I2C_GET_I2C_7BIT_ADDRESS(I2C_RX_FIFO_RD_REG);
 413:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 414:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ClearRxInterruptSource(I2C_INTR_RX_NOT_EMPTY);
 415:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 416:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Check received address against device addresses */
 417:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         if(I2C_addrBuf1 == locByte)
 418:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 419:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Set buffer exposed to primary slave address */
 420:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_dataBuffer = I2C_dataBuffer1;
 421:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_bufSizeBuf = I2C_bufSizeBuf1;
 422:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_protectBuf = I2C_protectBuf1;
 423:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 424:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             activeAddress = I2C_EZI2C_ACTIVE_ADDRESS1;
 425:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 426:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         else if(I2C_addrBuf2 == locByte)
 427:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 428:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Set buffer exposed to secondary slave address */
 429:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_dataBuffer = I2C_dataBuffer2;
 430:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_bufSizeBuf = I2C_bufSizeBuf2;
 431:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_protectBuf = I2C_protectBuf2;
 432:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 433:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             activeAddress = I2C_EZI2C_ACTIVE_ADDRESS2;
 434:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 435:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         else
 436:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 437:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Address does not match */
 438:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             ackResponse = I2C_EZI2C_NACK_RECEIVED_ADDRESS;
 439:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 440:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 441:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #endif
 442:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 443:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 #if(I2C_SECONDARY_ADDRESS_ENABLE_CONST)
 444:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     if(I2C_EZI2C_NACK_RECEIVED_ADDRESS == ackResponse)
 445:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 446:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Clear interrupt sources before NACK address */
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 18


 447:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ClearI2CExtClkInterruptSource(I2C_INTR_I2C_EC_WAKE_UP);
 448:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 449:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 450:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #if(!I2C_CY_SCBIP_V0)
 451:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Disable INTR_I2C_STOP to not trigger after matched address is NACKed. Ti
 452:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_DISABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_STOP);
 453:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #endif /* (!I2C_CY_SCBIP_V0) */
 454:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 455:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* NACK address byte: it does not match neither primary nor secondary */
 456:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_I2C_SLAVE_GENERATE_NACK;
 457:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 458:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     else
 459:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 #endif /* (I2C_SECONDARY_ADDRESS_ENABLE_CONST) */
 460:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 461:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 462:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #if(I2C_SCB_MODE_UNCONFIG_CONST_CFG)
 463:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         if(!I2C_SECONDARY_ADDRESS_ENABLE)
 464:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 465:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Set buffer exposed to primary slave address */
 466:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_dataBuffer = I2C_dataBuffer1;
 467:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_bufSizeBuf = I2C_bufSizeBuf1;
 468:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_protectBuf = I2C_protectBuf1;
 469:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 470:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             activeAddress = I2C_EZI2C_ACTIVE_ADDRESS1;
 471:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 472:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #endif /* (I2C_SCB_MODE_UNCONFIG_CONST_CFG) */
 473:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 474:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Bus becomes busy after address is received */
 475:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_curStatus |= (uint8) I2C_EZI2C_STATUS_BUSY;
 520              		.loc 1 475 0
 521 02ea 194B     		ldr	r3, .L40+20
 522 02ec 1B78     		ldrb	r3, [r3]
 523 02ee DBB2     		uxtb	r3, r3
 524 02f0 2022     		mov	r2, #32
 525 02f2 1343     		orr	r3, r2
 526 02f4 DAB2     		uxtb	r2, r3
 527 02f6 164B     		ldr	r3, .L40+20
 528 02f8 1A70     		strb	r2, [r3]
 476:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 477:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Slave is read or written: set current offset */
 478:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locIndex = I2C_EZI2C_GET_OFFSET(activeAddress);
 529              		.loc 1 478 0
 530 02fa 174B     		ldr	r3, .L40+28
 531 02fc 1B78     		ldrb	r3, [r3]
 532 02fe FB61     		str	r3, [r7, #28]
 479:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 480:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Check transaction direction */
 481:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         if(I2C_CHECK_I2C_STATUS(I2C_I2C_STATUS_S_READ))
 533              		.loc 1 481 0
 534 0300 264B     		ldr	r3, .L40+96
 535 0302 1B68     		ldr	r3, [r3]
 536 0304 1022     		mov	r2, #16
 537 0306 1340     		and	r3, r2
 538 0308 4ED0     		beq	.L34
 482:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 483:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Calculate slave buffer size */
 484:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             locBufSize = I2C_bufSizeBuf1 - (uint16) locIndex;
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 19


 539              		.loc 1 484 0
 540 030a 214B     		ldr	r3, .L40+84
 541 030c 1A88     		ldrh	r2, [r3]
 542 030e FB69     		ldr	r3, [r7, #28]
 543 0310 9BB2     		uxth	r3, r3
 544 0312 D31A     		sub	r3, r2, r3
 545 0314 9AB2     		uxth	r2, r3
 546 0316 1B4B     		ldr	r3, .L40+72
 547 0318 1A80     		strh	r2, [r3]
 485:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 486:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Clear TX FIFO to start fill from offset */
 487:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_CLEAR_TX_FIFO;
 548              		.loc 1 487 0
 549 031a 214B     		ldr	r3, .L40+100
 550 031c 204A     		ldr	r2, .L40+100
 551 031e 1268     		ldr	r2, [r2]
 552 0320 8021     		mov	r1, #128
 553 0322 4902     		lsl	r1, r1, #9
 554 0324 0A43     		orr	r2, r1
 555 0326 1A60     		str	r2, [r3]
 556 0328 1D4B     		ldr	r3, .L40+100
 557 032a 1D4A     		ldr	r2, .L40+100
 558 032c 1268     		ldr	r2, [r2]
 559 032e 1D49     		ldr	r1, .L40+104
 560 0330 0A40     		and	r2, r1
 561 0332 1A60     		str	r2, [r3]
 488:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_SetTxInterruptMode(I2C_INTR_TX_EMPTY);
 562              		.loc 1 488 0
 563 0334 074B     		ldr	r3, .L40+24
 564 0336 1022     		mov	r2, #16
 565 0338 1A60     		str	r2, [r3]
 566 033a 38E0     		b	.L35
 567              	.L41:
 568              		.align	2
 569              	.L40:
 570 033c 00000000 		.word	I2C_customIntrHandler
 571 0340 00000000 		.word	I2C_indexBuf1
 572 0344 400F0740 		.word	1074204480
 573 0348 000E0740 		.word	1074204160
 574 034c 00000740 		.word	1074200576
 575 0350 00000000 		.word	I2C_curStatus
 576 0354 880F0740 		.word	1074204552
 577 0358 00000000 		.word	I2C_offsetBuf1
 578 035c 60000740 		.word	1074200672
 579 0360 FF5FFFFF 		.word	-40961
 580 0364 C80F0740 		.word	1074204616
 581 0368 C00F0740 		.word	1074204608
 582 036c ED0F0000 		.word	4077
 583 0370 FF0F0000 		.word	4095
 584 0374 00000000 		.word	I2C_fsmState
 585 0378 880E0740 		.word	1074204296
 586 037c CC0F0740 		.word	1074204620
 587 0380 40030740 		.word	1074201408
 588 0384 00000000 		.word	locBufSize.4740
 589 0388 6C000740 		.word	1074200684
 590 038c 00000000 		.word	I2C_dataBuffer1
 591 0390 00000000 		.word	I2C_bufSizeBuf1
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 20


 592 0394 00000000 		.word	I2C_protectBuf1
 593 0398 08030740 		.word	1074201352
 594 039c 64000740 		.word	1074200676
 595 03a0 04020740 		.word	1074201092
 596 03a4 FFFFFEFF 		.word	-65537
 597              	.L34:
 489:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 490:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         else
 491:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         {
 492:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             /* Master writes: enable reception interrupt. The FSM state was set in 
 493:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 598              		.loc 1 493 0
 599 03a8 1E4B     		ldr	r3, .L42
 600 03aa 0422     		mov	r2, #4
 601 03ac 1A60     		str	r2, [r3]
 602              	.L35:
 494:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         }
 495:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 496:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Clear interrupt sources before ACK address */
 497:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ClearI2CExtClkInterruptSource(I2C_INTR_I2C_EC_WAKE_UP);
 603              		.loc 1 497 0
 604 03ae 1E4B     		ldr	r3, .L42+4
 605 03b0 0122     		mov	r2, #1
 606 03b2 1A60     		str	r2, [r3]
 498:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 607              		.loc 1 498 0
 608 03b4 1D4B     		ldr	r3, .L42+8
 609 03b6 1E4A     		ldr	r2, .L42+12
 610 03b8 1A60     		str	r2, [r3]
 499:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 500:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #if (!I2C_CY_SCBIP_V0)
 501:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* Enable STOP to trigger after address match is ACKed. Ticket ID#156094 */
 502:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_ENABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_STOP);
 503:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     #endif /* (!I2C_CY_SCBIP_V0) */
 504:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 505:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         /* ACK the address byte */
 506:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_I2C_SLAVE_GENERATE_ACK;
 611              		.loc 1 506 0
 612 03ba 1E4B     		ldr	r3, .L42+16
 613 03bc 0122     		mov	r2, #1
 614 03be 1A60     		str	r2, [r3]
 615              	.L33:
 507:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 508:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
 509:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 510:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* Clear slave interrupt sources */
 511:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 I2C_ClearSlaveInterruptSource(locIntrSlave);
 616              		.loc 1 511 0
 617 03c0 1A4B     		ldr	r3, .L42+8
 618 03c2 FA68     		ldr	r2, [r7, #12]
 619 03c4 1A60     		str	r2, [r3]
 620              	.L30:
 512:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             }
 513:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 514:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             /* INTR_TX.EMPTY */
 515:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             /* Transmits data to the master: loads data into the TX FIFO. The 0xFF sends out if the
 516:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             * out the buffer. The address reception with a read flag clears the TX FIFO to be loade
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 21


 517:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             */
 518:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             if(0u != (I2C_GetInterruptCause() & I2C_INTR_CAUSE_TX))
 621              		.loc 1 518 0
 622 03c6 1C4B     		ldr	r3, .L42+20
 623 03c8 1B68     		ldr	r3, [r3]
 624 03ca 0422     		mov	r2, #4
 625 03cc 1340     		and	r3, r2
 626 03ce 21D0     		beq	.L7
 627              	.L38:
 519:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             {
 520:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 /* Put data into TX FIFO until there is a room */
 521:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 do
 522:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 {
 523:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     /* Check transmit buffer range: locBufSize calculates after address reception *
 524:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     if(0u != locBufSize)
 628              		.loc 1 524 0
 629 03d0 1A4B     		ldr	r3, .L42+24
 630 03d2 1B88     		ldrh	r3, [r3]
 631 03d4 002B     		cmp	r3, #0
 632 03d6 11D0     		beq	.L36
 525:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 526:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_TX_FIFO_WR_REG = (uint32) I2C_dataBuffer1[locIndex];
 633              		.loc 1 526 0
 634 03d8 194A     		ldr	r2, .L42+28
 635 03da 1A4B     		ldr	r3, .L42+32
 636 03dc 1968     		ldr	r1, [r3]
 637 03de FB69     		ldr	r3, [r7, #28]
 638 03e0 CB18     		add	r3, r1, r3
 639 03e2 1B78     		ldrb	r3, [r3]
 640 03e4 DBB2     		uxtb	r3, r3
 641 03e6 1360     		str	r3, [r2]
 527:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locIndex++;
 642              		.loc 1 527 0
 643 03e8 FB69     		ldr	r3, [r7, #28]
 644 03ea 0133     		add	r3, r3, #1
 645 03ec FB61     		str	r3, [r7, #28]
 528:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         locBufSize--;
 646              		.loc 1 528 0
 647 03ee 134B     		ldr	r3, .L42+24
 648 03f0 1B88     		ldrh	r3, [r3]
 649 03f2 013B     		sub	r3, r3, #1
 650 03f4 9AB2     		uxth	r2, r3
 651 03f6 114B     		ldr	r3, .L42+24
 652 03f8 1A80     		strh	r2, [r3]
 653 03fa 02E0     		b	.L37
 654              	.L36:
 529:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 530:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     else
 531:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     {
 532:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                         I2C_TX_FIFO_WR_REG = I2C_EZI2C_OVFL_RETURN;
 655              		.loc 1 532 0
 656 03fc 104B     		ldr	r3, .L42+28
 657 03fe FF22     		mov	r2, #255
 658 0400 1A60     		str	r2, [r3]
 659              	.L37:
 533:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                     }
 534:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 }
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 22


 535:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 while(I2C_EZI2C_FIFO_SIZE != I2C_GET_TX_FIFO_ENTRIES);
 660              		.loc 1 535 0
 661 0402 114B     		ldr	r3, .L42+36
 662 0404 1B68     		ldr	r3, [r3]
 663 0406 0F22     		mov	r2, #15
 664 0408 1340     		and	r3, r2
 665 040a 082B     		cmp	r3, #8
 666 040c E0D1     		bne	.L38
 536:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 537:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****                 I2C_ClearTxInterruptSource(I2C_INTR_TX_EMPTY);
 667              		.loc 1 537 0
 668 040e 0F4B     		ldr	r3, .L42+40
 669 0410 1022     		mov	r2, #16
 670 0412 1A60     		str	r2, [r3]
 671              	.L7:
 538:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****             }
 539:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         }
 540:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 541:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         /* Store local index copy into global variable */
 542:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         I2C_EZI2C_SET_INDEX(activeAddress, locIndex);
 672              		.loc 1 542 0
 673 0414 FB69     		ldr	r3, [r7, #28]
 674 0416 9AB2     		uxth	r2, r3
 675 0418 0D4B     		ldr	r3, .L42+44
 676 041a 1A80     		strh	r2, [r3]
 543:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 544:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #ifdef I2C_EZI2C_STRETCH_ISR_EXIT_CALLBACK
 545:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****         I2C_EZI2C_STRETCH_ISR_ExitCallback();
 546:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     #endif /* I2C_EZI2C_STRETCH_ISR_EXIT_CALLBACK */
 547:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c **** 
 548:.\Generated_Source\PSoC4/I2C_EZI2C_INT.c ****     }
 677              		.loc 1 548 0
 678 041c BD46     		mov	sp, r7
 679 041e 08B0     		add	sp, sp, #32
 680              		@ sp needed
 681 0420 80BD     		pop	{r7, pc}
 682              	.L43:
 683 0422 C046     		.align	2
 684              	.L42:
 685 0424 C80F0740 		.word	1074204616
 686 0428 800E0740 		.word	1074204288
 687 042c 400F0740 		.word	1074204480
 688 0430 FF0F0000 		.word	4095
 689 0434 6C000740 		.word	1074200684
 690 0438 000E0740 		.word	1074204160
 691 043c 00000000 		.word	locBufSize.4740
 692 0440 40020740 		.word	1074201152
 693 0444 00000000 		.word	I2C_dataBuffer1
 694 0448 08020740 		.word	1074201096
 695 044c 800F0740 		.word	1074204544
 696 0450 00000000 		.word	I2C_indexBuf1
 697              		.cfi_endproc
 698              	.LFE0:
 699              		.size	I2C_EZI2C_STRETCH_ISR, .-I2C_EZI2C_STRETCH_ISR
 700              		.bss
 701              		.align	1
 702              	locBufSize.4740:
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 23


 703 0000 0000     		.space	2
 704              		.text
 705              	.Letext0:
 706              		.file 2 "Generated_Source\\PSoC4/cytypes.h"
 707              		.file 3 ".\\Generated_Source\\PSoC4\\I2C_PVT.h"
 708              		.file 4 ".\\Generated_Source\\PSoC4\\I2C_EZI2C_PVT.h"
 709              		.section	.debug_info,"",%progbits
 710              	.Ldebug_info0:
 711 0000 B5010000 		.4byte	0x1b5
 712 0004 0400     		.2byte	0x4
 713 0006 00000000 		.4byte	.Ldebug_abbrev0
 714 000a 04       		.byte	0x4
 715 000b 01       		.uleb128 0x1
 716 000c 14000000 		.4byte	.LASF34
 717 0010 01       		.byte	0x1
 718 0011 9C010000 		.4byte	.LASF35
 719 0015 45010000 		.4byte	.LASF36
 720 0019 00000000 		.4byte	.Ldebug_ranges0+0
 721 001d 00000000 		.4byte	0
 722 0021 00000000 		.4byte	.Ldebug_line0
 723 0025 02       		.uleb128 0x2
 724 0026 01       		.byte	0x1
 725 0027 06       		.byte	0x6
 726 0028 9D020000 		.4byte	.LASF0
 727 002c 02       		.uleb128 0x2
 728 002d 01       		.byte	0x1
 729 002e 08       		.byte	0x8
 730 002f 15010000 		.4byte	.LASF1
 731 0033 02       		.uleb128 0x2
 732 0034 02       		.byte	0x2
 733 0035 05       		.byte	0x5
 734 0036 7D020000 		.4byte	.LASF2
 735 003a 02       		.uleb128 0x2
 736 003b 02       		.byte	0x2
 737 003c 07       		.byte	0x7
 738 003d B2000000 		.4byte	.LASF3
 739 0041 02       		.uleb128 0x2
 740 0042 04       		.byte	0x4
 741 0043 05       		.byte	0x5
 742 0044 94020000 		.4byte	.LASF4
 743 0048 02       		.uleb128 0x2
 744 0049 04       		.byte	0x4
 745 004a 07       		.byte	0x7
 746 004b 2D010000 		.4byte	.LASF5
 747 004f 02       		.uleb128 0x2
 748 0050 08       		.byte	0x8
 749 0051 05       		.byte	0x5
 750 0052 5D020000 		.4byte	.LASF6
 751 0056 02       		.uleb128 0x2
 752 0057 08       		.byte	0x8
 753 0058 07       		.byte	0x7
 754 0059 20020000 		.4byte	.LASF7
 755 005d 03       		.uleb128 0x3
 756 005e 04       		.byte	0x4
 757 005f 05       		.byte	0x5
 758 0060 696E7400 		.ascii	"int\000"
 759 0064 02       		.uleb128 0x2
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 24


 760 0065 04       		.byte	0x4
 761 0066 07       		.byte	0x7
 762 0067 FE010000 		.4byte	.LASF8
 763 006b 04       		.uleb128 0x4
 764 006c 3F010000 		.4byte	.LASF9
 765 0070 02       		.byte	0x2
 766 0071 A1       		.byte	0xa1
 767 0072 2C000000 		.4byte	0x2c
 768 0076 04       		.uleb128 0x4
 769 0077 DA010000 		.4byte	.LASF10
 770 007b 02       		.byte	0x2
 771 007c A2       		.byte	0xa2
 772 007d 3A000000 		.4byte	0x3a
 773 0081 04       		.uleb128 0x4
 774 0082 F7010000 		.4byte	.LASF11
 775 0086 02       		.byte	0x2
 776 0087 A3       		.byte	0xa3
 777 0088 48000000 		.4byte	0x48
 778 008c 02       		.uleb128 0x2
 779 008d 04       		.byte	0x4
 780 008e 04       		.byte	0x4
 781 008f 06010000 		.4byte	.LASF12
 782 0093 02       		.uleb128 0x2
 783 0094 08       		.byte	0x8
 784 0095 04       		.byte	0x4
 785 0096 C5010000 		.4byte	.LASF13
 786 009a 02       		.uleb128 0x2
 787 009b 01       		.byte	0x1
 788 009c 08       		.byte	0x8
 789 009d 6B020000 		.4byte	.LASF14
 790 00a1 05       		.uleb128 0x5
 791 00a2 6B000000 		.4byte	0x6b
 792 00a6 06       		.uleb128 0x6
 793 00a7 0E000000 		.4byte	.LASF15
 794 00ab 02       		.byte	0x2
 795 00ac 4D01     		.2byte	0x14d
 796 00ae B2000000 		.4byte	0xb2
 797 00b2 05       		.uleb128 0x5
 798 00b3 81000000 		.4byte	0x81
 799 00b7 06       		.uleb128 0x6
 800 00b8 47020000 		.4byte	.LASF16
 801 00bc 02       		.byte	0x2
 802 00bd 5D01     		.2byte	0x15d
 803 00bf C3000000 		.4byte	0xc3
 804 00c3 07       		.uleb128 0x7
 805 00c4 04       		.byte	0x4
 806 00c5 C9000000 		.4byte	0xc9
 807 00c9 08       		.uleb128 0x8
 808 00ca 02       		.uleb128 0x2
 809 00cb 04       		.byte	0x4
 810 00cc 07       		.byte	0x7
 811 00cd 54020000 		.4byte	.LASF17
 812 00d1 09       		.uleb128 0x9
 813 00d2 E1010000 		.4byte	.LASF37
 814 00d6 01       		.byte	0x1
 815 00d7 26       		.byte	0x26
 816 00d8 00000000 		.4byte	.LFB0
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 25


 817 00dc 54040000 		.4byte	.LFE0-.LFB0
 818 00e0 01       		.uleb128 0x1
 819 00e1 9C       		.byte	0x9c
 820 00e2 5A010000 		.4byte	0x15a
 821 00e6 0A       		.uleb128 0xa
 822 00e7 0B020000 		.4byte	.LASF18
 823 00eb 01       		.byte	0x1
 824 00ec 28       		.byte	0x28
 825 00ed 76000000 		.4byte	0x76
 826 00f1 05       		.uleb128 0x5
 827 00f2 03       		.byte	0x3
 828 00f3 00000000 		.4byte	locBufSize.4740
 829 00f7 0A       		.uleb128 0xa
 830 00f8 0C010000 		.4byte	.LASF19
 831 00fc 01       		.byte	0x1
 832 00fd 29       		.byte	0x29
 833 00fe 81000000 		.4byte	0x81
 834 0102 02       		.uleb128 0x2
 835 0103 91       		.byte	0x91
 836 0104 74       		.sleb128 -12
 837 0105 0A       		.uleb128 0xa
 838 0106 23010000 		.4byte	.LASF20
 839 010a 01       		.byte	0x1
 840 010b 2A       		.byte	0x2a
 841 010c 81000000 		.4byte	0x81
 842 0110 02       		.uleb128 0x2
 843 0111 91       		.byte	0x91
 844 0112 70       		.sleb128 -16
 845 0113 0A       		.uleb128 0xa
 846 0114 C5000000 		.4byte	.LASF21
 847 0118 01       		.byte	0x1
 848 0119 2C       		.byte	0x2c
 849 011a 81000000 		.4byte	0x81
 850 011e 02       		.uleb128 0x2
 851 011f 91       		.byte	0x91
 852 0120 6C       		.sleb128 -20
 853 0121 0A       		.uleb128 0xa
 854 0122 16020000 		.4byte	.LASF22
 855 0126 01       		.byte	0x1
 856 0127 2D       		.byte	0x2d
 857 0128 81000000 		.4byte	0x81
 858 012c 02       		.uleb128 0x2
 859 012d 91       		.byte	0x91
 860 012e 68       		.sleb128 -24
 861 012f 0A       		.uleb128 0xa
 862 0130 A9020000 		.4byte	.LASF23
 863 0134 01       		.byte	0x1
 864 0135 2E       		.byte	0x2e
 865 0136 81000000 		.4byte	0x81
 866 013a 02       		.uleb128 0x2
 867 013b 91       		.byte	0x91
 868 013c 5C       		.sleb128 -36
 869 013d 0A       		.uleb128 0xa
 870 013e 87020000 		.4byte	.LASF24
 871 0142 01       		.byte	0x1
 872 0143 30       		.byte	0x30
 873 0144 81000000 		.4byte	0x81
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 26


 874 0148 02       		.uleb128 0x2
 875 0149 91       		.byte	0x91
 876 014a 60       		.sleb128 -32
 877 014b 0A       		.uleb128 0xa
 878 014c 70020000 		.4byte	.LASF25
 879 0150 01       		.byte	0x1
 880 0151 31       		.byte	0x31
 881 0152 81000000 		.4byte	0x81
 882 0156 02       		.uleb128 0x2
 883 0157 91       		.byte	0x91
 884 0158 64       		.sleb128 -28
 885 0159 00       		.byte	0
 886 015a 0B       		.uleb128 0xb
 887 015b D1000000 		.4byte	.LASF26
 888 015f 03       		.byte	0x3
 889 0160 3A       		.byte	0x3a
 890 0161 B7000000 		.4byte	0xb7
 891 0165 0B       		.uleb128 0xb
 892 0166 CC010000 		.4byte	.LASF27
 893 016a 04       		.byte	0x4
 894 016b 1D       		.byte	0x1d
 895 016c A1000000 		.4byte	0xa1
 896 0170 0B       		.uleb128 0xb
 897 0171 8F010000 		.4byte	.LASF28
 898 0175 04       		.byte	0x4
 899 0176 1E       		.byte	0x1e
 900 0177 6B000000 		.4byte	0x6b
 901 017b 0B       		.uleb128 0xb
 902 017c E7000000 		.4byte	.LASF29
 903 0180 04       		.byte	0x4
 904 0181 21       		.byte	0x21
 905 0182 86010000 		.4byte	0x186
 906 0186 07       		.uleb128 0x7
 907 0187 04       		.byte	0x4
 908 0188 A1000000 		.4byte	0xa1
 909 018c 0B       		.uleb128 0xb
 910 018d 37020000 		.4byte	.LASF30
 911 0191 04       		.byte	0x4
 912 0192 22       		.byte	0x22
 913 0193 76000000 		.4byte	0x76
 914 0197 0B       		.uleb128 0xb
 915 0198 A2000000 		.4byte	.LASF31
 916 019c 04       		.byte	0x4
 917 019d 23       		.byte	0x23
 918 019e 76000000 		.4byte	0x76
 919 01a2 0B       		.uleb128 0xb
 920 01a3 F7000000 		.4byte	.LASF32
 921 01a7 04       		.byte	0x4
 922 01a8 24       		.byte	0x24
 923 01a9 6B000000 		.4byte	0x6b
 924 01ad 0B       		.uleb128 0xb
 925 01ae 00000000 		.4byte	.LASF33
 926 01b2 04       		.byte	0x4
 927 01b3 25       		.byte	0x25
 928 01b4 76000000 		.4byte	0x76
 929 01b8 00       		.byte	0
 930              		.section	.debug_abbrev,"",%progbits
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 27


 931              	.Ldebug_abbrev0:
 932 0000 01       		.uleb128 0x1
 933 0001 11       		.uleb128 0x11
 934 0002 01       		.byte	0x1
 935 0003 25       		.uleb128 0x25
 936 0004 0E       		.uleb128 0xe
 937 0005 13       		.uleb128 0x13
 938 0006 0B       		.uleb128 0xb
 939 0007 03       		.uleb128 0x3
 940 0008 0E       		.uleb128 0xe
 941 0009 1B       		.uleb128 0x1b
 942 000a 0E       		.uleb128 0xe
 943 000b 55       		.uleb128 0x55
 944 000c 17       		.uleb128 0x17
 945 000d 11       		.uleb128 0x11
 946 000e 01       		.uleb128 0x1
 947 000f 10       		.uleb128 0x10
 948 0010 17       		.uleb128 0x17
 949 0011 00       		.byte	0
 950 0012 00       		.byte	0
 951 0013 02       		.uleb128 0x2
 952 0014 24       		.uleb128 0x24
 953 0015 00       		.byte	0
 954 0016 0B       		.uleb128 0xb
 955 0017 0B       		.uleb128 0xb
 956 0018 3E       		.uleb128 0x3e
 957 0019 0B       		.uleb128 0xb
 958 001a 03       		.uleb128 0x3
 959 001b 0E       		.uleb128 0xe
 960 001c 00       		.byte	0
 961 001d 00       		.byte	0
 962 001e 03       		.uleb128 0x3
 963 001f 24       		.uleb128 0x24
 964 0020 00       		.byte	0
 965 0021 0B       		.uleb128 0xb
 966 0022 0B       		.uleb128 0xb
 967 0023 3E       		.uleb128 0x3e
 968 0024 0B       		.uleb128 0xb
 969 0025 03       		.uleb128 0x3
 970 0026 08       		.uleb128 0x8
 971 0027 00       		.byte	0
 972 0028 00       		.byte	0
 973 0029 04       		.uleb128 0x4
 974 002a 16       		.uleb128 0x16
 975 002b 00       		.byte	0
 976 002c 03       		.uleb128 0x3
 977 002d 0E       		.uleb128 0xe
 978 002e 3A       		.uleb128 0x3a
 979 002f 0B       		.uleb128 0xb
 980 0030 3B       		.uleb128 0x3b
 981 0031 0B       		.uleb128 0xb
 982 0032 49       		.uleb128 0x49
 983 0033 13       		.uleb128 0x13
 984 0034 00       		.byte	0
 985 0035 00       		.byte	0
 986 0036 05       		.uleb128 0x5
 987 0037 35       		.uleb128 0x35
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 28


 988 0038 00       		.byte	0
 989 0039 49       		.uleb128 0x49
 990 003a 13       		.uleb128 0x13
 991 003b 00       		.byte	0
 992 003c 00       		.byte	0
 993 003d 06       		.uleb128 0x6
 994 003e 16       		.uleb128 0x16
 995 003f 00       		.byte	0
 996 0040 03       		.uleb128 0x3
 997 0041 0E       		.uleb128 0xe
 998 0042 3A       		.uleb128 0x3a
 999 0043 0B       		.uleb128 0xb
 1000 0044 3B       		.uleb128 0x3b
 1001 0045 05       		.uleb128 0x5
 1002 0046 49       		.uleb128 0x49
 1003 0047 13       		.uleb128 0x13
 1004 0048 00       		.byte	0
 1005 0049 00       		.byte	0
 1006 004a 07       		.uleb128 0x7
 1007 004b 0F       		.uleb128 0xf
 1008 004c 00       		.byte	0
 1009 004d 0B       		.uleb128 0xb
 1010 004e 0B       		.uleb128 0xb
 1011 004f 49       		.uleb128 0x49
 1012 0050 13       		.uleb128 0x13
 1013 0051 00       		.byte	0
 1014 0052 00       		.byte	0
 1015 0053 08       		.uleb128 0x8
 1016 0054 15       		.uleb128 0x15
 1017 0055 00       		.byte	0
 1018 0056 27       		.uleb128 0x27
 1019 0057 19       		.uleb128 0x19
 1020 0058 00       		.byte	0
 1021 0059 00       		.byte	0
 1022 005a 09       		.uleb128 0x9
 1023 005b 2E       		.uleb128 0x2e
 1024 005c 01       		.byte	0x1
 1025 005d 3F       		.uleb128 0x3f
 1026 005e 19       		.uleb128 0x19
 1027 005f 03       		.uleb128 0x3
 1028 0060 0E       		.uleb128 0xe
 1029 0061 3A       		.uleb128 0x3a
 1030 0062 0B       		.uleb128 0xb
 1031 0063 3B       		.uleb128 0x3b
 1032 0064 0B       		.uleb128 0xb
 1033 0065 27       		.uleb128 0x27
 1034 0066 19       		.uleb128 0x19
 1035 0067 11       		.uleb128 0x11
 1036 0068 01       		.uleb128 0x1
 1037 0069 12       		.uleb128 0x12
 1038 006a 06       		.uleb128 0x6
 1039 006b 40       		.uleb128 0x40
 1040 006c 18       		.uleb128 0x18
 1041 006d 9642     		.uleb128 0x2116
 1042 006f 19       		.uleb128 0x19
 1043 0070 01       		.uleb128 0x1
 1044 0071 13       		.uleb128 0x13
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 29


 1045 0072 00       		.byte	0
 1046 0073 00       		.byte	0
 1047 0074 0A       		.uleb128 0xa
 1048 0075 34       		.uleb128 0x34
 1049 0076 00       		.byte	0
 1050 0077 03       		.uleb128 0x3
 1051 0078 0E       		.uleb128 0xe
 1052 0079 3A       		.uleb128 0x3a
 1053 007a 0B       		.uleb128 0xb
 1054 007b 3B       		.uleb128 0x3b
 1055 007c 0B       		.uleb128 0xb
 1056 007d 49       		.uleb128 0x49
 1057 007e 13       		.uleb128 0x13
 1058 007f 02       		.uleb128 0x2
 1059 0080 18       		.uleb128 0x18
 1060 0081 00       		.byte	0
 1061 0082 00       		.byte	0
 1062 0083 0B       		.uleb128 0xb
 1063 0084 34       		.uleb128 0x34
 1064 0085 00       		.byte	0
 1065 0086 03       		.uleb128 0x3
 1066 0087 0E       		.uleb128 0xe
 1067 0088 3A       		.uleb128 0x3a
 1068 0089 0B       		.uleb128 0xb
 1069 008a 3B       		.uleb128 0x3b
 1070 008b 0B       		.uleb128 0xb
 1071 008c 49       		.uleb128 0x49
 1072 008d 13       		.uleb128 0x13
 1073 008e 3F       		.uleb128 0x3f
 1074 008f 19       		.uleb128 0x19
 1075 0090 3C       		.uleb128 0x3c
 1076 0091 19       		.uleb128 0x19
 1077 0092 00       		.byte	0
 1078 0093 00       		.byte	0
 1079 0094 00       		.byte	0
 1080              		.section	.debug_aranges,"",%progbits
 1081 0000 1C000000 		.4byte	0x1c
 1082 0004 0200     		.2byte	0x2
 1083 0006 00000000 		.4byte	.Ldebug_info0
 1084 000a 04       		.byte	0x4
 1085 000b 00       		.byte	0
 1086 000c 0000     		.2byte	0
 1087 000e 0000     		.2byte	0
 1088 0010 00000000 		.4byte	.LFB0
 1089 0014 54040000 		.4byte	.LFE0-.LFB0
 1090 0018 00000000 		.4byte	0
 1091 001c 00000000 		.4byte	0
 1092              		.section	.debug_ranges,"",%progbits
 1093              	.Ldebug_ranges0:
 1094 0000 00000000 		.4byte	.LFB0
 1095 0004 54040000 		.4byte	.LFE0
 1096 0008 00000000 		.4byte	0
 1097 000c 00000000 		.4byte	0
 1098              		.section	.debug_line,"",%progbits
 1099              	.Ldebug_line0:
 1100 0000 3D010000 		.section	.debug_str,"MS",%progbits,1
 1100      02008300 
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 30


 1100      00000201 
 1100      FB0E0D00 
 1100      01010101 
 1101              	.LASF33:
 1102 0000 4932435F 		.ascii	"I2C_indexBuf1\000"
 1102      696E6465 
 1102      78427566 
 1102      3100
 1103              	.LASF15:
 1104 000e 72656733 		.ascii	"reg32\000"
 1104      3200
 1105              	.LASF34:
 1106 0014 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 1106      4320342E 
 1106      392E3320 
 1106      32303135 
 1106      30333033 
 1107 0047 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0 -mthumb -g -O"
 1107      20726576 
 1107      6973696F 
 1107      6E203232 
 1107      31323230 
 1108 007a 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 1108      66756E63 
 1108      74696F6E 
 1108      2D736563 
 1108      74696F6E 
 1109              	.LASF31:
 1110 00a2 4932435F 		.ascii	"I2C_protectBuf1\000"
 1110      70726F74 
 1110      65637442 
 1110      75663100 
 1111              	.LASF3:
 1112 00b2 73686F72 		.ascii	"short unsigned int\000"
 1112      7420756E 
 1112      7369676E 
 1112      65642069 
 1112      6E7400
 1113              	.LASF21:
 1114 00c5 656E6454 		.ascii	"endTransfer\000"
 1114      72616E73 
 1114      66657200 
 1115              	.LASF26:
 1116 00d1 4932435F 		.ascii	"I2C_customIntrHandler\000"
 1116      63757374 
 1116      6F6D496E 
 1116      74724861 
 1116      6E646C65 
 1117              	.LASF29:
 1118 00e7 4932435F 		.ascii	"I2C_dataBuffer1\000"
 1118      64617461 
 1118      42756666 
 1118      65723100 
 1119              	.LASF32:
 1120 00f7 4932435F 		.ascii	"I2C_offsetBuf1\000"
 1120      6F666673 
 1120      65744275 
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 31


 1120      663100
 1121              	.LASF12:
 1122 0106 666C6F61 		.ascii	"float\000"
 1122      7400
 1123              	.LASF19:
 1124 010c 6C6F6349 		.ascii	"locIndex\000"
 1124      6E646578 
 1124      00
 1125              	.LASF1:
 1126 0115 756E7369 		.ascii	"unsigned char\000"
 1126      676E6564 
 1126      20636861 
 1126      7200
 1127              	.LASF20:
 1128 0123 6C6F6353 		.ascii	"locStatus\000"
 1128      74617475 
 1128      7300
 1129              	.LASF5:
 1130 012d 6C6F6E67 		.ascii	"long unsigned int\000"
 1130      20756E73 
 1130      69676E65 
 1130      6420696E 
 1130      7400
 1131              	.LASF9:
 1132 013f 75696E74 		.ascii	"uint8\000"
 1132      3800
 1133              	.LASF36:
 1134 0145 433A5C43 		.ascii	"C:\\Cypress\\IR_sensor_controller\\SCB_Bootloader\\"
 1134      79707265 
 1134      73735C49 
 1134      525F7365 
 1134      6E736F72 
 1135 0174 49525F73 		.ascii	"IR_sensor_controller.cydsn\000"
 1135      656E736F 
 1135      725F636F 
 1135      6E74726F 
 1135      6C6C6572 
 1136              	.LASF28:
 1137 018f 4932435F 		.ascii	"I2C_fsmState\000"
 1137      66736D53 
 1137      74617465 
 1137      00
 1138              	.LASF35:
 1139 019c 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\I2C_EZI2C_INT.c\000"
 1139      6E657261 
 1139      7465645F 
 1139      536F7572 
 1139      63655C50 
 1140              	.LASF13:
 1141 01c5 646F7562 		.ascii	"double\000"
 1141      6C6500
 1142              	.LASF27:
 1143 01cc 4932435F 		.ascii	"I2C_curStatus\000"
 1143      63757253 
 1143      74617475 
 1143      7300
 1144              	.LASF10:
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 32


 1145 01da 75696E74 		.ascii	"uint16\000"
 1145      313600
 1146              	.LASF37:
 1147 01e1 4932435F 		.ascii	"I2C_EZI2C_STRETCH_ISR\000"
 1147      455A4932 
 1147      435F5354 
 1147      52455443 
 1147      485F4953 
 1148              	.LASF11:
 1149 01f7 75696E74 		.ascii	"uint32\000"
 1149      333200
 1150              	.LASF8:
 1151 01fe 756E7369 		.ascii	"unsigned int\000"
 1151      676E6564 
 1151      20696E74 
 1151      00
 1152              	.LASF18:
 1153 020b 6C6F6342 		.ascii	"locBufSize\000"
 1153      75665369 
 1153      7A6500
 1154              	.LASF22:
 1155 0216 6669666F 		.ascii	"fifoIndex\000"
 1155      496E6465 
 1155      7800
 1156              	.LASF7:
 1157 0220 6C6F6E67 		.ascii	"long long unsigned int\000"
 1157      206C6F6E 
 1157      6720756E 
 1157      7369676E 
 1157      65642069 
 1158              	.LASF30:
 1159 0237 4932435F 		.ascii	"I2C_bufSizeBuf1\000"
 1159      62756653 
 1159      697A6542 
 1159      75663100 
 1160              	.LASF16:
 1161 0247 63796973 		.ascii	"cyisraddress\000"
 1161      72616464 
 1161      72657373 
 1161      00
 1162              	.LASF17:
 1163 0254 73697A65 		.ascii	"sizetype\000"
 1163      74797065 
 1163      00
 1164              	.LASF6:
 1165 025d 6C6F6E67 		.ascii	"long long int\000"
 1165      206C6F6E 
 1165      6720696E 
 1165      7400
 1166              	.LASF14:
 1167 026b 63686172 		.ascii	"char\000"
 1167      00
 1168              	.LASF25:
 1169 0270 6C6F6349 		.ascii	"locIntrSlave\000"
 1169      6E747253 
 1169      6C617665 
 1169      00
ARM GAS  C:\Users\PC69\AppData\Local\Temp\ccA6QTul.s 			page 33


 1170              	.LASF2:
 1171 027d 73686F72 		.ascii	"short int\000"
 1171      7420696E 
 1171      7400
 1172              	.LASF24:
 1173 0287 6C6F6349 		.ascii	"locIntrCause\000"
 1173      6E747243 
 1173      61757365 
 1173      00
 1174              	.LASF4:
 1175 0294 6C6F6E67 		.ascii	"long int\000"
 1175      20696E74 
 1175      00
 1176              	.LASF0:
 1177 029d 7369676E 		.ascii	"signed char\000"
 1177      65642063 
 1177      68617200 
 1178              	.LASF23:
 1179 02a9 6C6F6342 		.ascii	"locByte\000"
 1179      79746500 
 1180              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
