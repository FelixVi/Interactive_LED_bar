class panel:

	def __init__(self, number, addr, flipped):
		#inputs:
		self.number = number    # panel number
		self.addr = addr		# panel I2C address
		self.flipped = flipped	# panel flipped 180 degrees?
		self.IRmap = []			# IR sensor map
		self.animap = []		# Animation map
        
	def set_IRmap(self, IRmap):
		self.IRmap = IRmap

	def set_animap(self, animap):
		self.animap = animap

class barmodule:
	
	def __init__(self):
		self.panels=[]
		self.rowsPerPanel = 7
		self.colsPerPanel = 7
		self.unusedLEDsPerPanel = 1
		self.IRbaseReg = 36
		self.IRregwidth = 2
		self.lednobyxy=[]
		self.ledxbyno=[]
		self.ledybyno=[]
		self.IRaddresses=[]
		self.IRregisters=[]
		
	def add_panel(self, panel):
		self.panels.append(panel)
		
	#this function allows us to translate x,y locations to LED numbers
	def populateGrids(self):
		self.lednobyxy = []
		self.ledxbyno=[]
		self.ledybyno=[]
		self.IRaddresses=[]
		self.IRregisters=[]
		#Go through each panel
		for i in range(self.colsPerPanel):
			self.lednobyxy.append([])
		cnt = 0
		for pan in range(len(self.panels)):
			start = self.panels[pan].number*self.colsPerPanel;
			stop = start+self.colsPerPanel;
			#fill cols/rows
			idx=0
			for i in range(start,stop):
				for j in range(self.rowsPerPanel):
					#Different pending if wire btw panels is flipped
					k = i;
					if (self.panels[pan].flipped):
						k = i + 1
					if (k%2 == 0):
						self.lednobyxy[cnt%self.rowsPerPanel].append((i * self.rowsPerPanel) + j + self.unusedLEDsPerPanel*pan)
					else:
						self.lednobyxy[cnt%self.rowsPerPanel].append((i * self.rowsPerPanel) + (self.rowsPerPanel-1 - j) + self.unusedLEDsPerPanel*pan)
					cnt=cnt+1
				idx=idx+1
		#populating x coordinate lookup
		for i in range((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)):
			found = False
			for j in range(self.colsPerPanel):
				if i in self.lednobyxy[j]:
					self.ledxbyno.append(j)
					found = True
			if found == False:
				self.ledxbyno.append(255)
				
		#populating y coordinate lookup
		for i in range((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)):
			found = False
			for j in range(self.colsPerPanel):
				if i in self.lednobyxy[j]:
					self.ledybyno.append(self.lednobyxy[j].index(i))
					found = True
			if found == False:
				self.ledybyno.append(255)
		
		#populating IR node addresses
		for i in range(len(self.panels)):
			for p in range(len(self.panels[i].IRmap)):
				self.IRaddresses.append(self.panels[i].addr)
				
		#populating IR node registers
		for i in range(len(self.panels)):
			for p in range(len(self.panels[i].IRmap)):
				self.IRregisters.append(self.panels[i].IRmap[p] * self.IRregwidth + self.IRbaseReg)
						
	def generateC(self, filename):
		header = open("{0}.h".format(filename), "w")
		header.write("//Autogenerated file for LED and IR sensor mapping - DO NOT EDIT MANUALLY\n");
		header.write("extern const int lednobyxy[{0}][{1}];\n".format(self.colsPerPanel,self.rowsPerPanel))
		header.write("extern const int lednobyxy[{0}];\n".format((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)))
		header.write("extern const int lednobyxy[{0}];\n".format((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)))
		header.write("extern const int IRaddr[{0}];\n".format(len(self.panels) * len(self.panels[0].IRmap)))
		header.write("extern const int IRreg[{0}];\n".format(len(self.panels) * len(self.panels[0].IRmap)))
		
		cfile = open("{0}.c".format(filename), "w")
		cfile.write("//Autogenerated file for LED and IR sensor mapping - DO NOT EDIT MANUALLY\n");
		cfile.write("const int lednobyxy[{0}][{1}] = {{\n\t{{ ".format(self.colsPerPanel,self.rowsPerPanel))
		for y in range(self.colsPerPanel):
			for x in range(self.rowsPerPanel):
				cfile.write("{0} ".format(self.lednobyxy[y][x]))
				if x < self.rowsPerPanel - 1:
					cfile.write(", ")
				else:
					cfile.write("} \n")
					if y < self.colsPerPanel - 1:
						cfile.write("\t{ ")
		cfile.write("\t};\n\n")
		
		cfile.write("const int ledxbyno[{0}] = \n\t{{ ".format((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)))
		for x in range((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)):
			cfile.write("{0} ".format(self.ledxbyno[x]))
			if x < (self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels) - 1:
				cfile.write(", ")
			if (x+1)%self.colsPerPanel == 0:
				cfile.write("\n\t")
		cfile.write("\n\t};\n\n")
		
		cfile.write("const int ledybyno[{0}] = \n\t{{ ".format((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)))
		for x in range((self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels)):
			cfile.write("{0} ".format(self.ledybyno[x]))
			if x < (self.rowsPerPanel * self.colsPerPanel + self.unusedLEDsPerPanel) * len(self.panels) - 1:
				cfile.write(", ")
			if (x+1)%self.colsPerPanel == 0:
				cfile.write("\n\t")
		cfile.write("\n\t};\n\n")
		
		cfile.write("const int IRaddr[{0}] = \n\t{{ ".format(len(self.panels) * len(self.panels[0].IRmap)))
		for x in range(len(self.panels) * len(self.panels[0].IRmap)):
			cfile.write("{0} ".format(self.IRaddresses[x]))
			if x < (len(self.panels) * len(self.panels[0].IRmap)) - 1:
				cfile.write(", ")
			if (x+1)%4 == 0:
				cfile.write("\n\t")
		cfile.write("\n\t};\n\n")
		
		cfile.write("const int IRreg[{0}] = \n\t{{ ".format(len(self.panels) * len(self.panels[0].IRmap)))
		for x in range(len(self.panels) * len(self.panels[0].IRmap)):
			cfile.write("{0} ".format(self.IRregisters[x]))
			if x < (len(self.panels) * len(self.panels[0].IRmap)) - 1:
				cfile.write(", ")
			if (x+1)%4 == 0:
				cfile.write("\n\t")
		cfile.write("\n\t};\n\n")
		

#readNodes wants (addr,panelno)
#I suggest defining an array to look up the addr as well as corresponding registers
#then, we just call readNodes() to populate arrays nodeResults and nodeDiffs
#to check for trigger, we can then go through nodeDiffs and check if elements are > threshold
